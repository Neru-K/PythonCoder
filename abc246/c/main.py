# C - Coupon

##解法 2パターンに場合わけしてシミュレーション

"""
Aを下記の2パターンに場合わけして考える必要がある。
・商品の値段がクーポンの金額以上である場合（A[i] >= X の場合）
・商品の値段がクーポンの金額未満である場合（A[i] < X の場合）

しかし、上記の場合わけをしながらシミュレーションをしていくと条件分岐が意外と複雑になってしまう。
そのため、いったんクーポンがK枚しかないという点を無視し、「各商品においてクーポンを無駄なく使い切れる枚数の総和」をcとして算出しておく。
その上で下記のように場合わけをする。

「各商品においてクーポンを無駄なく使い切れる枚数の総和」をcとした場合、

・c >= 実際に所持しているクーポンの枚数（K）である *Point1
・c < 実際に所持しているクーポンの枚数（K）である *Point2

上記2点で場合わけをする理由は、Point1のパターンではクーポンをフルに使い切ったとしても無駄なく使い切れて端数を生まない一方、Point2のパターンは端数を生んでしまうためできる限り端数を少なく使い切りたいからである。
（たとえば800円の商品に1000円のクーポンを使用したら、200円は端数となり値引き金額として計上できない）

であるからして、Point2の場合にはできる限り端数を少なくしたい → 端数の大きな金額順にソートしてから順番に使用していきたい、ということになる。
そのため各商品の端数を代入しておくリストmodsを定義しておき、それを降順にソートする。 *Point3
"""

N, K, X = map(int, input().split())
A = list(map(int, input().split()))

# Aの合計金額
sum = 0
c = 0
mods = []

for i in range(N):
    c += A[i] // X
    sum += A[i]
    mods.append(A[i] % X)

# Point1
if c >= K:
    sum -= K * X
# Point2
else:
    sum -= c * X
    # Point3
    sorted = sorted(mods, reverse=True)
    K = min(K - c, N)
    for i in range(0, K):
        sum -= sorted[i]


print(sum)
